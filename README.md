算术表达式求值的思路和实现

要求：给出任意算术表达式，例如：-0.5-2*((-1.25+6)*2-(3-2)*-2)，1要做到语法检测，2要算出其值。

思路：根据编译原理，在词法分析阶段通过自定义DFA来对表达式进行切词，按顺序分割出操作数和操作符。然后把词法分析的结果作为入参传入语法分析过程，检测语法是否正确。在词法分析和语法分析都未检测到错误之后执行表达式求值运算。表达式求值的过程中用到两个栈，分别是专门存放操作数的操作数栈和专门存放操作符的操作符栈。操作符栈开始有一项特殊处理就是先将字符“=”压栈，以便最后可以判断运算过程是否即将结束。
由于在表达式中的操作符{“+”，“-”， “*”，“/”，“(", ")”, "="}之间是存在优先级关系的，所以在封装算术表达式运算的类中会定义一个算符优先表，运算的过程也就是基于算符优先表和两个栈的基础上进行的。

另外在词法分析过程中为了方便DFA的定义区分“-”是操作符还是操作数中的负数的一部分，所以先要对算术表达式进行一次规范化调整。例如原先的算术表达式："-5-2.508"，调整后变成"-5+ (-2.508)="。

在分词阶段的DFA的定义（如果需要扩展的话可以自己随意扩展）：

    有穷字母表：{'0..9', '+', '-', '*', '/', '(', ')', '='}
    有限状态集：{0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, OPERAND=>(100), OPERATOR=>(101)}
    初态：0
    终态：{OPERAND=>(100), OPERATOR=>(101)}
    单值映射关系：
        (0, '1..9')-->1        (0, '-')-->4    (0, '0')-->5
        (0, '(')-->6
        (0, ')')-->7
        (0, '+')-->8
        (0, '*')-->10
        (0, '/')-->11
        (1, '0..9)-->1
        (1, '.')-->2
        (1, {'+','-','*','/',')','='})-->OPERAND
        (2, '0..9')-->3
        (3, '0..9')-->3
        (3, {'+','-','*','/',')','='})-->OPERAND
        (4, '1..9')-->1
        (4, '(')-->OPERATOR
        (4, '0')-->5
        (5, '.')-->2
        (5, {'+','-','*','/',')','='})-->OPERAND
        (6, {'0..9', '-', '(', ')'})-->OPERATOR
        (7, {'+','-','*','/',')','='})-->OPERATOR
        (8, {'0..9', '('})-->OPERATOR
        (10, {'0..9', '('})-->OPERATOR
        (11, {'0..9', '('})-->OPERATOR
        
在表达式运算过程中的算符优先表的定义如下：

       | "+", "-", "*", "/", "(", ")", "=" |
       |-----------------------------------|
    "+"| '>', '>', '<', '<', '<', '>', '>' |
    "-"| '>', '>', '<', '<', '<', '>', '>' |
    "*"| '>', '>', '>', '>', '<', '>', '>' |
    "/"| '>', '>', '>', '>', '<', '>', '>' |
    "("| '<', '<', '<', '<', '<', '=', ' ' |
    ")"| '>', '>', '>', '>', ' ', '>', '>' |
    "="| '<', '<', '<', '<', '<', ' ', '=' |
       |-----------------------------------|
          
语法分析阶段的文法定义：
原始的贴近人类思维的文法产生式：

    E->E+F|E-F|E*F|E/F|F
    
    F->(E)|i
    
很容易得出消除左递归后的文法产生式定义如下：

    E->FE'
    
    E'->+FE'|-FE'|*FE'|/FE'|空
    
    F->(E)|i
    
    
其中非终结符E是表达式，非终结符F是表达式中的因子。

终结符：{'+', '-', '*', '/', '(', ')'，'i'}，其中i是操作数。

开始符是E

目前本程序采用了两种语法分析方式，分别是有递归的预测分析和非递归的预测分析。具体的分析思路在代码中注解了详细分析步骤。
程序是用c++写的。

